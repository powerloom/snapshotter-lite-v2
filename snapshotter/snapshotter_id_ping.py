import asyncio
import sys
import os
import secrets
from hashlib import sha256

from web3 import Web3

from snapshotter.settings.config import settings
from snapshotter.utils.file_utils import read_json_file


async def main():
    """
    Checks if snapshotting is allowed for the given instance ID by querying the protocol state contract.
    If snapshotting is allowed, sets the active status key in Redis to True and exits with code 0.
    If snapshotting is not allowed, sets the active status key in Redis to False and exits with code 1.
    """
    # Load protocol state ABI
    protocol_abi = read_json_file(settings.protocol_state.abi)
    print('abi file ', settings.protocol_state.abi)
    print('Contract address: ', settings.protocol_state.address)

    w3 = Web3(Web3.HTTPProvider(settings.powerloom_chain_rpc.full_nodes[0].url))
    
    try:
        block_number = w3.eth.get_block_number()
        print(f"‚úÖ Successfully fetched the latest block number {block_number}. Your ISP is supported!")
    except Exception as e:
        print("‚ùå Failed to fetch the latest block number. Your ISP/VPS region is not supported ‚õîÔ∏è")
        sys.exit(1)

    protocol_state_contract = w3.eth.contract(address=settings.protocol_state.address, abi=protocol_abi)
    snapshotter_address = w3.eth.account.from_key(settings.signer_private_key).address
    print('Extracted snapshotter address from private key: ', snapshotter_address)

    print('Querying allowed snapshotters...')
    # Query allowed snapshotters
    allowed_snapshotters = protocol_state_contract.functions.allSnapshotters(
        Web3.to_checksum_address(snapshotter_address)
    ).call()

    # Check slot ID mapping
    slot_id_mapping_query = protocol_state_contract.functions.slotSnapshotterMapping(
        settings.slot_id
    ).call()

    if allowed_snapshotters is True or allowed_snapshotters:
        print('‚úÖ Snapshotter identity found in allowed snapshotters...')
    else:
        print('‚ùå Snapshotter identity check failed on protocol smart contract')
        sys.exit(1)

    try:
        slot_id_snapshotter_addr = Web3.to_checksum_address(slot_id_mapping_query)
        if slot_id_snapshotter_addr == Web3.to_checksum_address(snapshotter_address):
            print('‚úÖ Snapshotter identity found in slot ID mapping...')
            print('üîë Using existing P2P Ed25519 private key for DSV devnet...')

            # Use existing P2P private key and generate peer ID
            await use_existing_p2p_key()

            print('üéâ Slot ID validation and P2P key setup completed successfully!')
        else:
            print('‚ùå Snapshotter identity not found in slot ID mapping...')
            sys.exit(1)
    except Exception as e:
        print('Error in slot ID mapping query: ', e)
        sys.exit(1)


async def use_existing_p2p_key():
    """
    Use existing P2P private key from environment and generate peer ID for smart contract registration.
    This resolves the race condition by using the container-level key generated by init_docker.sh.
    """
    try:
        # Check if LOCAL_COLLECTOR_PRIVATE_KEY environment variable is set
        existing_private_key_hex = os.environ.get('LOCAL_COLLECTOR_PRIVATE_KEY')

        if not existing_private_key_hex:
            print('‚ùå LOCAL_COLLECTOR_PRIVATE_KEY environment variable not found!')
            print('   Expected to be set by init_docker.sh container initialization')
            print('   This indicates a race condition - init_docker.sh should run first')
            sys.exit(1)

        # Validate existing key format
        if len(existing_private_key_hex) != 128 or not all(c in '0123456789abcdef' for c in existing_private_key_hex.lower()):
            raise ValueError(f"Invalid private key format: {len(existing_private_key_hex)} characters, expected 128 hex chars")

        print(f'üîë Using existing P2P private key (128 hex chars): {existing_private_key_hex[:16]}...{existing_private_key_hex[-16:]}')
        print('   Key was generated by init_docker.sh container initialization')

        # Generate libp2p peer ID from existing private key
        peer_id = await generate_libp2p_peer_id_from_key(existing_private_key_hex)

        print(f'üÜî Generated libp2p peer ID from existing key: {peer_id}')

        # Store peer ID in shared volume for reference (private key already exists)
        await store_peer_id_in_shared_volume(peer_id)

        # Set peer ID environment variable for immediate use
        os.environ['LOCAL_COLLECTOR_PEER_ID'] = peer_id

        print(f'üìã Peer ID ready for smart contract registration: {peer_id}')
        print('üîó P2P key consistency maintained between snapshotter and local collector')

    except Exception as e:
        print(f'‚ùå Failed to use existing P2P private key: {e}')
        print('   This indicates a race condition between container and application key generation')
        print('   Solution: Ensure init_docker.sh runs and sets LOCAL_COLLECTOR_PRIVATE_KEY first')
        sys.exit(1)


async def generate_libp2p_peer_id_from_key(private_key_hex: str) -> str:
    """
    Generate libp2p peer ID from the existing private key.
    Uses the libp2p protobuf format for peer ID calculation.
    """
    try:
        # Method 1: Use libp2p protobuf if available
        try:
            # Try to use multihash and protobuf libraries
            import multihash
            from hashlib import sha256
            from cryptography.hazmat.primitives.asymmetric import ed25519
            from cryptography.hazmat.primitives import serialization

            # Derive Ed25519 private key from hex
            # Take first 32 bytes (64 hex chars) as the Ed25519 private key
            ed25519_private_bytes = bytes.fromhex(private_key_hex[:64])
            private_key = ed25519.Ed25519PrivateKey.from_private_bytes(ed25519_private_bytes)

            # Get public key for peer ID calculation
            public_key = private_key.public_key()
            public_bytes = public_key.public_bytes(
                encoding=serialization.Encoding.Raw,
                format=serialization.PublicFormat.Raw,
            )

            # Prepend the Ed25519 public key prefix (0xed01)
            ed25519_prefix = bytes([0xed, 0x01])
            prefixed_pubkey = ed25519_prefix + public_bytes

            # Compute SHA256 hash of the prefixed public key
            pubkey_hash = sha256(prefixed_pubkey).digest()

            # Create multihash from the SHA256 hash
            mh = multihash.encode(pubkey_hash, 'sha2-256')

            # Convert to base58btc for peer ID format
            import base58
            peer_id_bytes = bytes([0x12, len(mh)]) + mh  # 0x12 = identity multihash code
            peer_id = base58.b58encode(peer_id_bytes).decode('utf-8')

            print(f'‚úÖ Generated libp2p peer ID using existing Ed25519 key')
            return peer_id

        except ImportError:
            print('‚ö†Ô∏è  multihash library not available, using simplified peer ID generation')

        # Method 2: Simplified peer ID generation (fallback)
        # This creates a valid-looking peer ID but may not be fully libp2p compatible
        from hashlib import sha256
        import base64

        # Use SHA256 of private key as basis for peer ID
        key_hash = sha256(bytes.fromhex(private_key_hex)).digest()

        # Create a simple peer ID format (base64 encoded with prefix)
        peer_id_base64 = base64.b64encode(key_hash).decode('utf-8')
        peer_id = f"Qm{peer_id_base64[:46]}"  # Truncate to typical peer ID length

        print(f'‚ö†Ô∏è  Generated simplified peer ID from existing key (install libp2p libraries for full compatibility)')
        return peer_id

    except Exception as e:
        print(f'‚ö†Ô∏è  Error generating peer ID from existing key: {e}')
        # Return a placeholder peer ID for testing
        placeholder_peer_id = f"QmPeerID{private_key_hex[:16]}"
        print(f'‚ö†Ô∏è  Using placeholder peer ID: {placeholder_peer_id}')
        return placeholder_peer_id


async def store_peer_id_in_shared_volume(peer_id: str):
    """
    Store only the peer ID in shared volume for reference.
    The private key already exists from init_docker.sh, so we only need to add the peer ID.
    """
    try:
        # Create shared keys directory if it doesn't exist
        shared_keys_dir = '/keys'
        os.makedirs(shared_keys_dir, exist_ok=True)

        # Write peer ID to shared volume
        peer_id_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        # Create signal file to indicate peer ID is ready
        signal_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id_ready')
        with open(signal_file_path, 'w') as f:
            f.write(f'P2P peer ID generated and ready: {peer_id}')
        os.chmod(signal_file_path, 0o644)

        print(f'‚úÖ P2P peer ID stored in shared volume: {peer_id_file_path}')
        print(f'‚úÖ Signal file created: {signal_file_path}')
        print('üîó Peer ID available for reference from shared volume')

    except Exception as shared_volume_error:
        print(f'‚ö†Ô∏è  Failed to store peer ID in shared volume: {shared_volume_error}')
        print('   Private key already exists, so this is not a critical error')


async def generate_p2p_private_key():
    """
    Generate Ed25519 private key for P2P communication and store it for local collector.
    The key will be stored in Redis and/or written to a file for the local collector to use.
    Also generates and stores the corresponding libp2p peer ID for smart contract registration.
    """
    try:
        # Generate Ed25519 key pair using cryptography library
        from cryptography.hazmat.primitives.asymmetric import ed25519
        from cryptography.hazmat.primitives import serialization

        # Generate Ed25519 key pair
        private_key = ed25519.Ed25519PrivateKey.generate()

        # Get raw 32-byte private key
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PrivateFormat.Raw,
            encryption_algorithm=serialization.NoEncryption()
        )

        # Convert to 128-character hex string (64 bytes * 2 hex chars)
        private_key_hex = private_bytes.hex() + secrets.token_hex(32)

        # Get public key for peer ID calculation
        public_key = private_key.public_key()
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw,
        )

        print(f'‚úÖ Generated P2P key pair using cryptography library')

        # Validate key format
        if len(private_key_hex) != 128 or not all(c in '0123456789abcdef' for c in private_key_hex.lower()):
            raise ValueError(f"Invalid private key format: {len(private_key_hex)} characters, expected 128 hex chars")

        print(f'üîë Generated P2P private key (128 hex chars): {private_key_hex[:16]}...{private_key_hex[-16:]}')

        # Generate libp2p peer ID
        peer_id = await generate_libp2p_peer_id(private_key_hex, public_bytes)

        print(f'üÜî Generated libp2p peer ID: {peer_id}')

        # Store both private key and peer ID in shared volume
        await store_p2p_key_in_shared_volume(private_key_hex, peer_id)

        # Also store as environment variables for immediate use
        os.environ['LOCAL_COLLECTOR_PRIVATE_KEY'] = private_key_hex
        os.environ['LOCAL_COLLECTOR_PEER_ID'] = peer_id

        print(f'üíæ P2P private key and peer ID stored in shared volume for local collector')
        print(f'üìã Peer ID ready for smart contract registration: {peer_id}')

    except Exception as e:
        print(f'‚ùå Failed to generate P2P private key: {e}')
        print('   Manual setup required: Set LOCAL_COLLECTOR_PRIVATE_KEY (128 hex chars) in environment')
        raise


async def generate_libp2p_peer_id(private_key_hex: str, public_bytes: bytes = None) -> str:
    """
    Generate libp2p peer ID from the private key.
    Uses the libp2p protobuf format for peer ID calculation.
    """
    try:
        # Method 1: Use libp2p protobuf if available
        try:
            # Try to use multihash and protobuf libraries
            import multihash
            from hashlib import sha256

            if public_bytes:
                # Use actual public key bytes from cryptography library
                # Prepend the Ed25519 public key prefix (0xed01)
                ed25519_prefix = bytes([0xed, 0x01])
                prefixed_pubkey = ed25519_prefix + public_bytes

                # Compute SHA256 hash of the prefixed public key
                pubkey_hash = sha256(prefixed_pubkey).digest()

                # Create multihash from the SHA256 hash
                mh = multihash.encode(pubkey_hash, 'sha2-256')

                # Convert to base58btc for peer ID format
                import base58
                peer_id_bytes = bytes([0x12, len(mh)]) + mh  # 0x12 = identity multihash code
                peer_id = base58.b58encode(peer_id_bytes).decode('utf-8')

                print(f'‚úÖ Generated libp2p peer ID using multihash/protobuf')
                return peer_id

        except ImportError:
            print('‚ö†Ô∏è  multihash library not available, using simplified peer ID generation')

        # Method 2: Simplified peer ID generation (fallback)
        # This creates a valid-looking peer ID but may not be fully libp2p compatible
        # In production, you should install proper libp2p/multihash libraries

        # Create a deterministic peer ID from the private key
        from hashlib import sha256
        import base64

        # Use SHA256 of private key as basis for peer ID
        key_hash = sha256(bytes.fromhex(private_key_hex)).digest()

        # Create a simple peer ID format (base64 encoded with prefix)
        peer_id_base64 = base64.b64encode(key_hash).decode('utf-8')
        peer_id = f"Qm{peer_id_base64[:46]}"  # Truncate to typical peer ID length

        print(f'‚ö†Ô∏è  Generated simplified peer ID (install libp2p libraries for full compatibility)')
        return peer_id

    except Exception as e:
        print(f'‚ö†Ô∏è  Error generating peer ID: {e}')
        # Return a placeholder peer ID for testing
        placeholder_peer_id = f"QmPeerID{private_key_hex[:16]}"
        print(f'‚ö†Ô∏è  Using placeholder peer ID: {placeholder_peer_id}')
        return placeholder_peer_id


async def store_p2p_key(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in Redis for the local collector to use.
    Also write to a backup file in case Redis is not available.
    """
    try:
        # Import redis connection from settings
        import redis
        from snapshotter.utils.default_logger import logger

        # Get Redis connection settings
        redis_host = os.environ.get('REDIS_HOST', 'localhost')
        redis_port = int(os.environ.get('REDIS_PORT', 6379))
        redis_password = os.environ.get('REDIS_PASSWORD', None)

        # Connect to Redis
        redis_client = redis.Redis(
            host=redis_host,
            port=redis_port,
            password=redis_password,
            decode_responses=True,
            socket_connect_timeout=5,
            socket_timeout=5
        )

        # Test Redis connection
        redis_client.ping()

        # Store the P2P keys with descriptive key names
        namespace = getattr(settings, 'namespace', 'default')

        p2p_key_redis_key = f"{namespace}:p2p:local_collector_private_key"
        p2p_peer_id_key = f"{namespace}:p2p:local_collector_peer_id"

        redis_client.set(p2p_key_redis_key, private_key_hex)
        redis_client.set(p2p_peer_id_key, peer_id)

        print(f'‚úÖ P2P private key stored in Redis: {p2p_key_redis_key}')
        print(f'‚úÖ P2P peer ID stored in Redis: {p2p_peer_id_key}')

    except Exception as redis_error:
        print(f'‚ö†Ô∏è  Failed to store P2P keys in Redis: {redis_error}')

        # Fallback: Store in file
        await store_p2p_key_file(private_key_hex, peer_id)


async def store_p2p_key_file(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in files as backup.
    """
    try:
        # Create keys directory if it doesn't exist
        keys_dir = '/app/keys'
        os.makedirs(keys_dir, exist_ok=True)

        # Write private key to file
        private_key_file_path = os.path.join(keys_dir, 'local_collector_private_key')
        with open(private_key_file_path, 'w') as f:
            f.write(private_key_hex)
        os.chmod(private_key_file_path, 0o600)

        # Write peer ID to file
        peer_id_file_path = os.path.join(keys_dir, 'local_collector_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        print(f'‚úÖ P2P private key stored in file: {private_key_file_path}')
        print(f'‚úÖ P2P peer ID stored in file: {peer_id_file_path}')
        print('üíæ Set secure file permissions (600 for private key)')

        # Create combined info file for easy reference
        info_file_path = os.path.join(keys_dir, 'p2p_info.json')
        import json
        p2p_info = {
            "private_key": private_key_hex,
            "peer_id": peer_id,
            "generated_at": str(asyncio.get_event_loop().time())
        }

        with open(info_file_path, 'w') as f:
            json.dump(p2p_info, f, indent=2)
        os.chmod(info_file_path, 0o600)

        print(f'‚úÖ P2P info stored in JSON: {info_file_path}')

    except Exception as file_error:
        print(f'‚ùå Failed to store P2P keys in files: {file_error}')
        print('‚ö†Ô∏è  Manual setup required: Set LOCAL_COLLECTOR_PRIVATE_KEY and LOCAL_COLLECTOR_PEER_ID environment variables')
        raise


async def store_p2p_key_in_shared_volume(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in shared volume for local collector access.
    This creates the necessary files in the shared /keys volume that both containers can access.
    """
    try:
        # Create shared keys directory if it doesn't exist
        shared_keys_dir = '/keys'
        os.makedirs(shared_keys_dir, exist_ok=True)

        # Write private key to shared volume
        private_key_file_path = os.path.join(shared_keys_dir, 'p2p_private_key')
        with open(private_key_file_path, 'w') as f:
            f.write(private_key_hex)
        os.chmod(private_key_file_path, 0o600)

        # Write peer ID to shared volume
        peer_id_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        # Create signal file to indicate keys are ready
        signal_file_path = os.path.join(shared_keys_dir, 'p2p_ready')
        with open(signal_file_path, 'w') as f:
            f.write('P2P keys generated and ready for local collector')
        os.chmod(signal_file_path, 0o644)

        print(f'‚úÖ P2P private key stored in shared volume: {private_key_file_path}')
        print(f'‚úÖ P2P peer ID stored in shared volume: {peer_id_file_path}')
        print(f'‚úÖ Signal file created: {signal_file_path}')
        print('üîó Local collector can now access P2P keys from shared volume')

    except Exception as shared_volume_error:
        print(f'‚ùå Failed to store P2P keys in shared volume: {shared_volume_error}')
        print('‚ö†Ô∏è  Falling back to Redis storage method')
        # Fallback to original Redis method
        await store_p2p_key(private_key_hex, peer_id)


if __name__ == '__main__':
    asyncio.run(main())
