import asyncio
import sys
import os

from web3 import Web3

from snapshotter.settings.config import settings
from snapshotter.utils.file_utils import read_json_file


async def main():
    """
    Checks if snapshotting is allowed for the given instance ID by querying the protocol state contract.
    If snapshotting is allowed, sets the active status key in Redis to True and exits with code 0.
    If snapshotting is not allowed, sets the active status key in Redis to False and exits with code 1.
    """
    # Load protocol state ABI
    protocol_abi = read_json_file(settings.protocol_state.abi)
    print('abi file ', settings.protocol_state.abi)
    print('Contract address: ', settings.protocol_state.address)

    w3 = Web3(Web3.HTTPProvider(settings.powerloom_chain_rpc.full_nodes[0].url))
    
    try:
        block_number = w3.eth.get_block_number()
        print(f"‚úÖ Successfully fetched the latest block number {block_number}. Your ISP is supported!")
    except Exception as e:
        print("‚ùå Failed to fetch the latest block number. Your ISP/VPS region is not supported ‚õîÔ∏è")
        sys.exit(1)

    protocol_state_contract = w3.eth.contract(address=settings.protocol_state.address, abi=protocol_abi)
    snapshotter_address = w3.eth.account.from_key(settings.signer_private_key).address
    print('Extracted snapshotter address from private key: ', snapshotter_address)

    print('Querying allowed snapshotters...')
    # Query allowed snapshotters
    allowed_snapshotters = protocol_state_contract.functions.allSnapshotters(
        Web3.to_checksum_address(snapshotter_address)
    ).call()

    # Check slot ID mapping
    slot_id_mapping_query = protocol_state_contract.functions.slotSnapshotterMapping(
        settings.slot_id
    ).call()

    if allowed_snapshotters is True or allowed_snapshotters:
        print('‚úÖ Snapshotter identity found in allowed snapshotters...')
    else:
        print('‚ùå Snapshotter identity check failed on protocol smart contract')
        sys.exit(1)

    try:
        slot_id_snapshotter_addr = Web3.to_checksum_address(slot_id_mapping_query)
        if slot_id_snapshotter_addr == Web3.to_checksum_address(snapshotter_address):
            print('‚úÖ Snapshotter identity found in slot ID mapping...')
            print('üîë Using existing P2P Ed25519 private key for DSV devnet...')

            # Use existing P2P private key
            await use_existing_p2p_key()

            print('üéâ Slot ID validation and P2P key setup completed successfully!')
        else:
            print('‚ùå Snapshotter identity not found in slot ID mapping...')
            sys.exit(1)
    except Exception as e:
        print('Error in slot ID mapping query: ', e)
        sys.exit(1)



async def use_existing_p2p_key():
    """
    Use existing P2P private key from environment.
    Validates that the key is available and properly formatted.
    """
    try:
        # Check if LOCAL_COLLECTOR_PRIVATE_KEY environment variable is set
        existing_private_key_hex = os.environ.get('LOCAL_COLLECTOR_PRIVATE_KEY')

        if not existing_private_key_hex:
            print('‚ùå LOCAL_COLLECTOR_PRIVATE_KEY environment variable not found!')
            print('   Expected to be set by init_docker.sh container initialization')
            print('   This indicates a race condition - init_docker.sh should run first')
            sys.exit(1)

        # Validate existing key format
        if len(existing_private_key_hex) != 64 or not all(c in '0123456789abcdef' for c in existing_private_key_hex.lower()):
            raise ValueError(f"Invalid private key format: {len(existing_private_key_hex)} characters, expected 64 hex chars")

        print(f'üîë Using existing P2P private key (64 hex chars): {existing_private_key_hex[:16]}...{existing_private_key_hex[-16:]}')
        print('   Key was generated by init_docker.sh container initialization')
        print('üîó P2P key ready for use by local collector')

    except Exception as e:
        print(f'‚ùå Failed to use existing P2P private key: {e}')
        print('   This indicates a race condition between container and application key generation')
        print('   Solution: Ensure init_docker.sh runs and sets LOCAL_COLLECTOR_PRIVATE_KEY first')
        sys.exit(1)












if __name__ == '__main__':
    asyncio.run(main())
