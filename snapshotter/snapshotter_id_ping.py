import asyncio
import sys
import os
import secrets
from hashlib import sha256

from web3 import Web3

from snapshotter.settings.config import settings
from snapshotter.utils.file_utils import read_json_file


async def main():
    """
    Checks if snapshotting is allowed for the given instance ID by querying the protocol state contract.
    If snapshotting is allowed, sets the active status key in Redis to True and exits with code 0.
    If snapshotting is not allowed, sets the active status key in Redis to False and exits with code 1.
    """
    # Load protocol state ABI
    protocol_abi = read_json_file(settings.protocol_state.abi)
    print('abi file ', settings.protocol_state.abi)
    print('Contract address: ', settings.protocol_state.address)

    w3 = Web3(Web3.HTTPProvider(settings.powerloom_chain_rpc.full_nodes[0].url))
    
    try:
        block_number = w3.eth.get_block_number()
        print(f"‚úÖ Successfully fetched the latest block number {block_number}. Your ISP is supported!")
    except Exception as e:
        print("‚ùå Failed to fetch the latest block number. Your ISP/VPS region is not supported ‚õîÔ∏è")
        sys.exit(1)

    protocol_state_contract = w3.eth.contract(address=settings.protocol_state.address, abi=protocol_abi)
    snapshotter_address = w3.eth.account.from_key(settings.signer_private_key).address
    print('Extracted snapshotter address from private key: ', snapshotter_address)

    print('Querying allowed snapshotters...')
    # Query allowed snapshotters
    allowed_snapshotters = protocol_state_contract.functions.allSnapshotters(
        Web3.to_checksum_address(snapshotter_address)
    ).call()

    # Check slot ID mapping
    slot_id_mapping_query = protocol_state_contract.functions.slotSnapshotterMapping(
        settings.slot_id
    ).call()

    if allowed_snapshotters is True or allowed_snapshotters:
        print('‚úÖ Snapshotter identity found in allowed snapshotters...')
    else:
        print('‚ùå Snapshotter identity check failed on protocol smart contract')
        sys.exit(1)

    try:
        slot_id_snapshotter_addr = Web3.to_checksum_address(slot_id_mapping_query)
        if slot_id_snapshotter_addr == Web3.to_checksum_address(snapshotter_address):
            print('‚úÖ Snapshotter identity found in slot ID mapping...')
            print('üîë Using existing P2P Ed25519 private key for DSV devnet...')

            # Use existing P2P private key and generate peer ID
            await use_existing_p2p_key()

            print('üéâ Slot ID validation and P2P key setup completed successfully!')
        else:
            print('‚ùå Snapshotter identity not found in slot ID mapping...')
            sys.exit(1)
    except Exception as e:
        print('Error in slot ID mapping query: ', e)
        sys.exit(1)


async def use_existing_p2p_key():
    """
    Use existing P2P private key from environment and generate peer ID for smart contract registration.
    This resolves the race condition by using the container-level key generated by init_docker.sh.
    """
    try:
        # Check if LOCAL_COLLECTOR_PRIVATE_KEY environment variable is set
        existing_private_key_hex = os.environ.get('LOCAL_COLLECTOR_PRIVATE_KEY')

        if not existing_private_key_hex:
            print('‚ùå LOCAL_COLLECTOR_PRIVATE_KEY environment variable not found!')
            print('   Expected to be set by init_docker.sh container initialization')
            print('   This indicates a race condition - init_docker.sh should run first')
            sys.exit(1)

        # Validate existing key format
        if len(existing_private_key_hex) != 128 or not all(c in '0123456789abcdef' for c in existing_private_key_hex.lower()):
            raise ValueError(f"Invalid private key format: {len(existing_private_key_hex)} characters, expected 128 hex chars")

        print(f'üîë Using existing P2P private key (128 hex chars): {existing_private_key_hex[:16]}...{existing_private_key_hex[-16:]}')
        print('   Key was generated by init_docker.sh container initialization')

        # Generate libp2p peer ID from existing private key
        peer_id = await generate_libp2p_peer_id_from_key(existing_private_key_hex)

        print(f'üÜî Generated libp2p peer ID from existing key: {peer_id}')

        # Store peer ID in shared volume for reference (private key already exists)
        await store_peer_id_in_shared_volume(peer_id)

        # Set peer ID environment variable for immediate use
        os.environ['LOCAL_COLLECTOR_PEER_ID'] = peer_id

        print(f'üìã Peer ID ready for smart contract registration: {peer_id}')
        print('üîó P2P key consistency maintained between snapshotter and local collector')

    except Exception as e:
        print(f'‚ùå Failed to use existing P2P private key: {e}')
        print('   This indicates a race condition between container and application key generation')
        print('   Solution: Ensure init_docker.sh runs and sets LOCAL_COLLECTOR_PRIVATE_KEY first')
        sys.exit(1)


async def generate_libp2p_peer_id_from_key(private_key_hex: str) -> str:
    """
    Generate libp2p peer ID from the existing private key.
    Uses the libp2p protobuf format for peer ID calculation with proper multihash support.
    """
    try:
        # Method 1: Use libp2p protobuf with multihash and base58 (now available in pyproject.toml)
        try:
            import multihash
            import base58
            from hashlib import sha256
            from cryptography.hazmat.primitives.asymmetric import ed25519
            from cryptography.hazmat.primitives import serialization

            print('üîß Using multihash and base58 libraries for proper libp2p peer ID generation')

            # Derive Ed25519 private key from hex
            # Take first 32 bytes (64 hex chars) as the Ed25519 private key seed
            ed25519_private_bytes = bytes.fromhex(private_key_hex[:64])
            private_key = ed25519.Ed25519PrivateKey.from_private_bytes(ed25519_private_bytes)

            # Get public key for peer ID calculation
            public_key = private_key.public_key()
            public_bytes = public_key.public_bytes(
                encoding=serialization.Encoding.Raw,
                format=serialization.PublicFormat.Raw,
            )

            # Prepend the Ed25519 public key prefix (0xed01) as per libp2p spec
            ed25519_prefix = bytes([0xed, 0x01])
            prefixed_pubkey = ed25519_prefix + public_bytes

            # Compute SHA256 hash of the prefixed public key
            pubkey_hash = sha256(prefixed_pubkey).digest()

            # Create multihash from the SHA256 hash
            mh = multihash.encode(pubkey_hash, 'sha2-256')

            # Convert to base58btc for proper libp2p peer ID format
            # Identity multihash code (0x12) + length + multihash
            peer_id_bytes = bytes([0x12, len(mh)]) + mh
            peer_id = base58.b58encode(peer_id_bytes).decode('utf-8')

            print(f'‚úÖ Generated proper libp2p peer ID using Ed25519 key: {peer_id}')
            print(f'   Public key bytes: {public_bytes.hex()}')
            print(f'   Prefixed public key: {prefixed_pubkey.hex()}')
            print(f'   SHA256 hash: {pubkey_hash.hex()}')
            print(f'   Multihash: {mh.hex()}')
            print(f'   Peer ID bytes: {peer_id_bytes.hex()}')

            # Validate peer ID format (should start with "12D3KooW" for Ed25519 keys)
            if peer_id.startswith('12D3KooW'):
                print(f'‚úÖ Peer ID has correct Ed25519 format')
            else:
                print(f'‚ö†Ô∏è  Peer ID does not have expected Ed25519 prefix, but may still be valid')

            return peer_id

        except ImportError as import_error:
            print(f'‚ùå Required libraries not available: {import_error}')
            print('   Ensure multihash and base58 are installed via poetry')
            raise import_error

    except Exception as e:
        print(f'‚ùå Error generating proper libp2p peer ID: {e}')
        print('   Falling back to simplified peer ID generation for compatibility')

        # Method 2: Simplified peer ID generation (fallback only if libraries fail)
        try:
            from hashlib import sha256
            import base64

            # Use SHA256 of private key as basis for peer ID
            key_hash = sha256(bytes.fromhex(private_key_hex)).digest()

            # Create a deterministic peer ID format
            peer_id_base64 = base64.b64encode(key_hash).decode('utf-8')
            peer_id = f"Qm{peer_id_base64[:46]}"  # Truncate to typical peer ID length

            print(f'‚ö†Ô∏è  Generated fallback peer ID: {peer_id}')
            print('   ‚ö†Ô∏è  This is not fully libp2p compatible - install dependencies for proper generation')
            return peer_id

        except Exception as fallback_error:
            print(f'‚ùå Even fallback peer ID generation failed: {fallback_error}')
            # Return a deterministic placeholder peer ID
            placeholder_peer_id = f"12D3KooW{private_key_hex[:48]}"
            print(f'‚ö†Ô∏è  Using deterministic placeholder peer ID: {placeholder_peer_id}')
            return placeholder_peer_id


async def store_peer_id_in_shared_volume(peer_id: str):
    """
    Store only the peer ID in shared volume for reference.
    The private key already exists from init_docker.sh, so we only need to add the peer ID.
    """
    try:
        # Create shared keys directory if it doesn't exist
        shared_keys_dir = '/keys'
        os.makedirs(shared_keys_dir, exist_ok=True)

        # Write peer ID to shared volume
        peer_id_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        # Create signal file to indicate peer ID is ready
        signal_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id_ready')
        with open(signal_file_path, 'w') as f:
            f.write(f'P2P peer ID generated and ready: {peer_id}')
        os.chmod(signal_file_path, 0o644)

        print(f'‚úÖ P2P peer ID stored in shared volume: {peer_id_file_path}')
        print(f'‚úÖ Signal file created: {signal_file_path}')
        print('üîó Peer ID available for reference from shared volume')

    except Exception as shared_volume_error:
        print(f'‚ö†Ô∏è  Failed to store peer ID in shared volume: {shared_volume_error}')
        print('   Private key already exists, so this is not a critical error')




async def generate_libp2p_peer_id(private_key_hex: str, public_bytes: bytes = None) -> str:
    """
    Generate libp2p peer ID from the private key.
    Uses the libp2p protobuf format for peer ID calculation with proper multihash support.
    """
    try:
        # Method 1: Use libp2p protobuf with multihash and base58 (now available in pyproject.toml)
        try:
            import multihash
            import base58
            from hashlib import sha256

            if public_bytes:
                # Use actual public key bytes from cryptography library
                print('üîß Using provided public key bytes for libp2p peer ID generation')

                # Prepend the Ed25519 public key prefix (0xed01) as per libp2p spec
                ed25519_prefix = bytes([0xed, 0x01])
                prefixed_pubkey = ed25519_prefix + public_bytes

                # Compute SHA256 hash of the prefixed public key
                pubkey_hash = sha256(prefixed_pubkey).digest()

                # Create multihash from the SHA256 hash
                mh = multihash.encode(pubkey_hash, 'sha2-256')

                # Convert to base58btc for proper libp2p peer ID format
                # Identity multihash code (0x12) + length + multihash
                peer_id_bytes = bytes([0x12, len(mh)]) + mh
                peer_id = base58.b58encode(peer_id_bytes).decode('utf-8')

                print(f'‚úÖ Generated proper libp2p peer ID using provided public key: {peer_id}')
                print(f'   Public key bytes: {public_bytes.hex()}')
                print(f'   Prefixed public key: {prefixed_pubkey.hex()}')
                print(f'   SHA256 hash: {pubkey_hash.hex()}')
                print(f'   Multihash: {mh.hex()}')
                print(f'   Peer ID bytes: {peer_id_bytes.hex()}')

                # Validate peer ID format
                if peer_id.startswith('12D3KooW'):
                    print(f'‚úÖ Peer ID has correct Ed25519 format')
                else:
                    print(f'‚ö†Ô∏è  Peer ID does not have expected Ed25519 prefix, but may still be valid')

                return peer_id

        except ImportError as import_error:
            print(f'‚ùå Required libraries not available: {import_error}')
            print('   Ensure multihash and base58 are installed via poetry')
            raise import_error

    except Exception as e:
        print(f'‚ùå Error generating proper libp2p peer ID: {e}')
        print('   Falling back to simplified peer ID generation for compatibility')

        # Method 2: Simplified peer ID generation (fallback only if libraries fail)
        try:
            from hashlib import sha256
            import base64

            # Create a deterministic peer ID from the private key
            key_hash = sha256(bytes.fromhex(private_key_hex)).digest()

            # Create a simple peer ID format (base64 encoded with prefix)
            peer_id_base64 = base64.b64encode(key_hash).decode('utf-8')
            peer_id = f"Qm{peer_id_base64[:46]}"  # Truncate to typical peer ID length

            print(f'‚ö†Ô∏è  Generated fallback peer ID: {peer_id}')
            print('   ‚ö†Ô∏è  This is not fully libp2p compatible - install dependencies for proper generation')
            return peer_id

        except Exception as fallback_error:
            print(f'‚ùå Even fallback peer ID generation failed: {fallback_error}')
            # Return a deterministic placeholder peer ID
            placeholder_peer_id = f"12D3KooW{private_key_hex[:48]}"
            print(f'‚ö†Ô∏è  Using deterministic placeholder peer ID: {placeholder_peer_id}')
            return placeholder_peer_id


async def store_p2p_key(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in Redis for the local collector to use.
    Also write to a backup file in case Redis is not available.
    """
    try:
        # Import redis connection from settings
        import redis
        from snapshotter.utils.default_logger import logger

        # Get Redis connection settings
        redis_host = os.environ.get('REDIS_HOST', 'localhost')
        redis_port = int(os.environ.get('REDIS_PORT', 6379))
        redis_password = os.environ.get('REDIS_PASSWORD', None)

        # Connect to Redis
        redis_client = redis.Redis(
            host=redis_host,
            port=redis_port,
            password=redis_password,
            decode_responses=True,
            socket_connect_timeout=5,
            socket_timeout=5
        )

        # Test Redis connection
        redis_client.ping()

        # Store the P2P keys with descriptive key names
        namespace = getattr(settings, 'namespace', 'default')

        p2p_key_redis_key = f"{namespace}:p2p:local_collector_private_key"
        p2p_peer_id_key = f"{namespace}:p2p:local_collector_peer_id"

        redis_client.set(p2p_key_redis_key, private_key_hex)
        redis_client.set(p2p_peer_id_key, peer_id)

        print(f'‚úÖ P2P private key stored in Redis: {p2p_key_redis_key}')
        print(f'‚úÖ P2P peer ID stored in Redis: {p2p_peer_id_key}')

    except Exception as redis_error:
        print(f'‚ö†Ô∏è  Failed to store P2P keys in Redis: {redis_error}')

        # Fallback: Store in file
        await store_p2p_key_file(private_key_hex, peer_id)


async def store_p2p_key_file(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in files as backup.
    """
    try:
        # Create keys directory if it doesn't exist
        keys_dir = '/app/keys'
        os.makedirs(keys_dir, exist_ok=True)

        # Write private key to file
        private_key_file_path = os.path.join(keys_dir, 'local_collector_private_key')
        with open(private_key_file_path, 'w') as f:
            f.write(private_key_hex)
        os.chmod(private_key_file_path, 0o600)

        # Write peer ID to file
        peer_id_file_path = os.path.join(keys_dir, 'local_collector_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        print(f'‚úÖ P2P private key stored in file: {private_key_file_path}')
        print(f'‚úÖ P2P peer ID stored in file: {peer_id_file_path}')
        print('üíæ Set secure file permissions (600 for private key)')

        # Create combined info file for easy reference
        info_file_path = os.path.join(keys_dir, 'p2p_info.json')
        import json
        p2p_info = {
            "private_key": private_key_hex,
            "peer_id": peer_id,
            "generated_at": str(asyncio.get_event_loop().time())
        }

        with open(info_file_path, 'w') as f:
            json.dump(p2p_info, f, indent=2)
        os.chmod(info_file_path, 0o600)

        print(f'‚úÖ P2P info stored in JSON: {info_file_path}')

    except Exception as file_error:
        print(f'‚ùå Failed to store P2P keys in files: {file_error}')
        print('‚ö†Ô∏è  Manual setup required: Set LOCAL_COLLECTOR_PRIVATE_KEY and LOCAL_COLLECTOR_PEER_ID environment variables')
        raise


async def store_p2p_key_in_shared_volume(private_key_hex: str, peer_id: str):
    """
    Store the P2P private key and peer ID in shared volume for local collector access.
    This creates the necessary files in the shared /keys volume that both containers can access.
    """
    try:
        # Create shared keys directory if it doesn't exist
        shared_keys_dir = '/keys'
        os.makedirs(shared_keys_dir, exist_ok=True)

        # Write private key to shared volume
        private_key_file_path = os.path.join(shared_keys_dir, 'p2p_private_key')
        with open(private_key_file_path, 'w') as f:
            f.write(private_key_hex)
        os.chmod(private_key_file_path, 0o600)

        # Write peer ID to shared volume
        peer_id_file_path = os.path.join(shared_keys_dir, 'p2p_peer_id')
        with open(peer_id_file_path, 'w') as f:
            f.write(peer_id)
        os.chmod(peer_id_file_path, 0o644)

        # Create signal file to indicate keys are ready
        signal_file_path = os.path.join(shared_keys_dir, 'p2p_ready')
        with open(signal_file_path, 'w') as f:
            f.write('P2P keys generated and ready for local collector')
        os.chmod(signal_file_path, 0o644)

        print(f'‚úÖ P2P private key stored in shared volume: {private_key_file_path}')
        print(f'‚úÖ P2P peer ID stored in shared volume: {peer_id_file_path}')
        print(f'‚úÖ Signal file created: {signal_file_path}')
        print('üîó Local collector can now access P2P keys from shared volume')

    except Exception as shared_volume_error:
        print(f'‚ùå Failed to store P2P keys in shared volume: {shared_volume_error}')
        print('‚ö†Ô∏è  Falling back to Redis storage method')
        # Fallback to original Redis method
        await store_p2p_key(private_key_hex, peer_id)


if __name__ == '__main__':
    asyncio.run(main())
